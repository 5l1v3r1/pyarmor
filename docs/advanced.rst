.. _advanced topics:

Advanced Topics
===============

Obfuscating Python Scripts In Different Modes
---------------------------------------------

.. _obfuscating module mode:

* obf_mod == 1

The final obfuscated scripts would like this::

    __pyarmor__(__name__, __file__, b'\x02\x0a...', 1)

The third parameter is serialized code object of the Python
script. It's generated by this way::

    PyObject *co = Py_CompileString( source, filename, Py_file_input );
    char *original_mod = marshal.dumps( co );
    char *obfuscated_mod = obfuscate_algorithm( original_code  );
    sprintf( buffer, "__pyarmor__(__name__, __file__, b'%s', 1)", obfuscated_mod );

* obf_mod == 0

In this mode, keep the serialized module as it is::

    sprintf( buffer, "__pyarmor__(__name__, __file__, b'%s', 0)", original_mod );

And the final obfuscated scripts would like this::

    __pyarmor__(__name__, __file__, b'\x02\x0a...', 0)

.. _obfuscating code mode:

In a python module file, generally there are many functions, each
function has its code object.

* obf_code == 0

The code object of each function will keep it as it is.

* obf_code == 1

In this case, the code object of each function will be obfuscated in
different ways depending on wrap mode.

.. _wrap mode:

* wrap_mode == 0

When wrap mode is off, the code object of each function will be
obfuscated as this form::

    0   JUMP_ABSOLUTE            n = 3 + len(bytecode)

    3    ...
         ... Here it's obfuscated bytecode of original function
         ...

    n   LOAD_GLOBAL              ? (__armor__)
    n+3 CALL_FUNCTION            0
    n+6 POP_TOP
    n+7 JUMP_ABSOLUTE            0

When this code object is called first time

1. First op is JUMP_ABSOLUTE, it will jump to offset n

2. At offset n, the instruction is to call PyCFunction
   `__armor__`. This function will restore those obfuscated bytecode
   between offset 3 and n, and move the original bytecode at offset 0

3. After function call, the last instruction is to jump to
   offset 0. The really bytecode now is executed.

After the first call, this function is same as the original one.

* wrap_mode == 1

When wrap mode is on, the code object of each function will be wrapped
with `try...finally` block::

    LOAD_GLOBALS    N (__armor_enter__)     N = length of co_consts
    CALL_FUNCTION   0
    POP_TOP
    SETUP_FINALLY   X (jump to wrap footer) X = size of original byte code

    Here it's obfuscated bytecode of original function

    LOAD_GLOBALS    N + 1 (__armor_exit__)
    CALL_FUNCTION   0
    POP_TOP
    END_FINALLY

When this code object is called each time

1. `__armor_enter__` will restore the obfuscated bytecode

2. Execute the real function code

3. In the final block, `__armor_exit__` will obfuscate bytecode again.

.. _restrict mode:

Restrict Mode
-------------

**DEPRECATED: This concept will be removed soon, use :ref:`Wrap Mode` instead**

|PyArmor| can obfuscate the scripts in restrict mode.

If the script is obfuscated in restrict mode:

* Each function (code object) will not be obfuscated again in runtime
* Any other code can not be insert into the obfuscated scripts
* The obfuscated module can not be imported from other clear python scripts

For examples, obfuscate :file:`foo.py` in restrict mode::

    pyarmor obfuscate --restrict foo.py

Each function is obfuscated before it's called. Once it's executed, it
will not be obfuscated again.

And if adding ``print`` in the obfuscated script::

    from pytransform import pyarmor_runtime
    pyarmor_runtime()
    __pyarmor__(__name__, __file__, b'...')
    print('Something')

It will report error as running::

    python foo.py

In a short word, the obfuscated script in restrict mode runs quickly,
but maybe less security.

If the scripts is obfuscated in restrict mode, you should enable
restrict mode either as generating new licenses for it::

    pyarmor licenses --restrict --expired 2019-01-01 mycode

.. include:: _common_definitions.txt
